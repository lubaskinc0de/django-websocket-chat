'''
тут пишем саму логику отправки и получения сообщений
это будет логика также подключения к комнатам
вообщем как views но для channels
consumer = views
'''

from asgiref.sync import async_to_sync
from channels.generic.websocket import WebsocketConsumer
import json

class ChatConsumer(WebsocketConsumer):
    '''
    создаем основной consumer(views) и наследуемся от именно websocketconsumer(они есть разные)
    websocketconsumer это синхронный consumer
    мы пишем сихронный код который будет обернут в асинхронный
    есть также асинхронный consumer
    '''
    def connect(self):
        '''
        функция самого коннекта к комнате
        будет возникать при каждом коннекте к какой то комнате
        '''

        self.room_name = self.scope['url_route']['kwargs']['room_name']

        '''
        scope это по сути тот же самый request который у нас есть во
        views django
        и мы можем достать из него информацию, url_route, kwargs, и имя комнаты которое было передано в маршруте(routing)
        тем самым узнаем какое название комнаты нам передали в маршруте
        '''

        self.room_group_name = 'chat_' + self.room_name

        '''то как будет называться чат к которому мы коннектимся
        в зависимости от переданного room_name, тоесть chat_alesha,chat_riba,chat_lubaskin и тд
        тоесть основное название нашего чата
        '''

        async_to_sync(self.channel_layer.group_add)(
            self.room_group_name,
            self.channel_name
        )
        '''
        синхронно запускаем aсинхронный процесс тоесть делаем из
        aсинхронного процесса синхронный, функцией;
        channel_layer = это сами каналы channel
        у них есть группы, мы добавляем в (чат) канал channel (пользователя)
        тоесть коннектим пользователя в группу
        '''
        
        self.accept() # и применяем все изменения которые мы сделали методом accept

        '''
        мы по сути просто забрали название комнаты которое нам прислали из маршрута(url)
        создали на основе этого названия имя группы
        и зарегистрировали(добавили канал(пользователя) в комнату)
        и просто методом accept() применили все изменения и приконнектились
        '''

    '''
    теперь пишем disconnect
    происходит когда мы отключаемся от комнаты(или по какой то причине закрываеться соединение)
    '''

    def disconnect(self, close_code):

        '''
        опять же вызываем функцию делающую aсинхронный код синхронным
        '''

        async_to_sync(self.channel_layer.group_discard)(
            self.room_group_name,
            self.channel_name
        )

        '''
        делаем абсолютно то же самое что делали выше с connect но вместо
        group_add мы используем group_discard
        тоесть отсоединяем от комнаты пользователя
        передаем название комнаты от которой отсоединяем
        и название канала(пользователя) которого надо отсоединить
        '''
    
    '''
    теперь пишем функцию которая будет принимать сообщения
    сообщения будут напечатаны пользователем и отправленные сюда json'ом
    это мы и будем принимать
    тоесть просто функция обрабатывающая переданное сообщение пользователя и потом посылающее его в другой метод 
    который и будет высвечивать это сообщение в чате
    '''

    def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json['message']

        '''
        через json loads мы получаем и обрабатываем полученные данные которые нам пришли по json(то что напечатал пользователь попало сюда)
        дальше мы создаем из него message в котором храниться сам текст сообщения переданный в text_data_json (извлекаем текст сообщения из всего массива json переданного пользователем)
        '''

        '''
        опять же вызываем функцию делающую aсинхронный код синхронным
        '''

        async_to_sync(self.channel_layer.group_send)(
            self.room_group_name,
            {
                'type': 'chat_message',
                'message': message
            }
        )

        '''
        и теперь то сообщение которое напечатал и отправил пользователь мы просто отправляем в другой метод который будет его выводить другим в чате
        указываем тип сообщения(chat_message)(это имя функции в которую отправиться json)
        и указываем сам взятый из отправленного пользователем json текст сообщения
        тоесть просто отправляем обработанный текст сообщения в другой метод который и выведет его другим
        '''

    '''
    теперь пишем функцию которая будет данные полученные из метода receive выводить в сам чат
    тоесть сама передача сообщения в чат на всеобщее обозрение
    '''

    def chat_message(self,event):
        message = event['message'] # достаем из event(отправленного нам из receive) текст сообщения
        
        self.send(text_data=json.dumps({
            'event':'Send',
            'message': message
        }))

        '''
        и теперь отправляем в чат обработанное сообщение которое пришло нам из receive(то которое напечатал пользователь)
        в качевстве event(события) указываем Send(отправку)
        и принятое из метода receive сообщение message
        все просто
        '''



